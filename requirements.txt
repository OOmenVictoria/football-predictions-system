name: Football Predictions Publishing

on:
  # Esegui automaticamente ogni 6 ore
  schedule:
    - cron: '0 */6 * * *'
  
  # Consenti l'esecuzione manuale
  workflow_dispatch:
    inputs:
      publish_only:
        description: 'Pubblica solo articoli in attesa'
        type: boolean
        default: false
      cleanup_only:
        description: 'Rimuovi solo articoli scaduti'
        type: boolean
        default: false
      test_mode:
        description: 'Esegui in modalità test'
        type: boolean
        default: false

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Create directories
        run: |
          mkdir -p logs
          mkdir -p data

      - name: Setup Firebase credentials
        run: |
          echo '${{ secrets.FIREBASE_CREDENTIALS }}' > firebase_credentials.json
          echo "FIREBASE_CREDENTIALS=$(pwd)/firebase_credentials.json" >> $GITHUB_ENV
          echo "FIREBASE_DB_URL=${{ secrets.FIREBASE_DB_URL }}" >> $GITHUB_ENV

      - name: Setup WordPress credentials
        run: |
          echo "WP_URL=${{ secrets.WP_URL }}" >> $GITHUB_ENV
          echo "WP_USER=${{ secrets.WP_USER }}" >> $GITHUB_ENV
          echo "WP_APP_PASSWORD=${{ secrets.WP_APP_PASSWORD }}" >> $GITHUB_ENV

      - name: Test WordPress connection
        run: |
          python -c "
import os
import requests
import sys
import logging

# Configura logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('wp_connection_test')

def test_wp_connection():
    wp_url = os.environ.get('WP_URL')
    wp_api_key = os.environ.get('WP_APP_PASSWORD')
    
    if not wp_url or not wp_api_key:
        logger.error('WordPress credentials not found in environment variables')
        sys.exit(1)
    
    # Test base URL
    try:
        logger.info(f'Testing connection to {wp_url}')
        response = requests.get(wp_url)
        logger.info(f'Response status: {response.status_code}')
        
        if response.status_code == 200:
            logger.info('✅ Base WordPress connection successful')
        else:
            logger.error(f'❌ Error connecting to WordPress: {response.status_code}')
            logger.error(response.text[:200])
            sys.exit(1)
    except Exception as e:
        logger.error(f'❌ Error: {str(e)}')
        sys.exit(1)
    
    # Test API key with custom endpoint
    try:
        custom_api_url = wp_url.replace('/wp/v2', '/football-predictions/v1/publish')
        logger.info(f'Testing API key with endpoint: {custom_api_url}')
        
        headers = {'X-API-Key': wp_api_key}
        response = requests.head(custom_api_url, headers=headers)
        
        logger.info(f'API response status: {response.status_code}')
        
        if response.status_code in [200, 401, 404]:
            logger.info('✅ API endpoint check passed')
            return True
        else:
            logger.error(f'❌ API endpoint check failed: {response.status_code}')
            if hasattr(response, 'text'):
                logger.error(response.text[:200])
            sys.exit(1)
    except Exception as e:
        logger.error(f'❌ API test error: {str(e)}')
        sys.exit(1)

test_wp_connection()
          "

      - name: Run publication cycle
        if: ${{ !inputs.publish_only && !inputs.cleanup_only }}
        run: |
          python -c "
import sys
import logging
import os
from datetime import datetime

# Configura logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('logs/publishing.log')
    ]
)
logger = logging.getLogger('publisher')

# Aggiungi la directory corrente al path
sys.path.insert(0, '.')

try:
    logger.info(f'Starting publication cycle at {datetime.now().isoformat()}')
    
    # Verifica disponibilità dei moduli
    logger.info('Importing publisher module...')
    from src.publishing.publisher import run_publication_cycle
    
    # Log delle variabili d'ambiente (senza valori sensibili)
    env_vars = {
        'WP_URL': os.environ.get('WP_URL', 'Not set'),
        'WP_USER': os.environ.get('WP_USER', 'Not set'),
        'WP_APP_PASSWORD': 'Set' if os.environ.get('WP_APP_PASSWORD') else 'Not set',
        'FIREBASE_DB_URL': os.environ.get('FIREBASE_DB_URL', 'Not set'),
        'FIREBASE_CREDENTIALS': 'Set' if os.environ.get('FIREBASE_CREDENTIALS') else 'Not set'
    }
    logger.info(f'Environment configuration: {env_vars}')
    
    # Esegui il ciclo di pubblicazione
    test_mode = ${{ inputs.test_mode || 'False' }}
    logger.info(f'Running publication cycle (test_mode={test_mode})...')
    
    result = run_publication_cycle(test_mode=test_mode)
    
    logger.info(f'Publication cycle completed: {result}')
except Exception as e:
    logger.error(f'Error during publication cycle: {str(e)}', exc_info=True)
    sys.exit(1)
          "

      - name: Publish pending articles only
        if: ${{ inputs.publish_only }}
        run: |
          python -c "
import sys
import logging
from datetime import datetime

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('logs/publishing.log')
    ]
)
logger = logging.getLogger('publisher')

# Aggiungi la directory corrente al path
sys.path.insert(0, '.')

try:
    logger.info(f'Starting publication of pending articles at {datetime.now().isoformat()}')
    from src.publishing.publisher import publish_articles
    
    test_mode = ${{ inputs.test_mode || 'False' }}
    logger.info(f'Running publish_articles (test_mode={test_mode})...')
    
    result = publish_articles(test_mode=test_mode)
    logger.info(f'Publish result: {result}')
except Exception as e:
    logger.error(f'Error during publication: {str(e)}', exc_info=True)
    sys.exit(1)
          "

      - name: Cleanup expired articles only
        if: ${{ inputs.cleanup_only }}
        run: |
          python -c "
import sys
import logging
from datetime import datetime

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('logs/publishing.log')
    ]
)
logger = logging.getLogger('publisher')

# Aggiungi la directory corrente al path
sys.path.insert(0, '.')

try:
    logger.info(f'Starting cleanup of expired articles at {datetime.now().isoformat()}')
    from src.publishing.publisher import cleanup_articles
    
    logger.info('Running cleanup_articles...')
    result = cleanup_articles()
    logger.info(f'Cleanup result: {result}')
except Exception as e:
    logger.error(f'Error during cleanup: {str(e)}', exc_info=True)
    sys.exit(1)
          "

      - name: Upload logs
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: publishing-logs-${{ github.run_id }}
          path: logs/
          retention-days: 7
